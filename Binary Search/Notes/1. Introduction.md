## 1. Definition / Idea

Binary Search is a **divide-and-conquer algorithm** for finding an element in a **sorted space** by repeatedly halving the search range.

## 2. Key Properties

- Works only on sorted data.
    
- Reduces search space by half at each step.
    
- Deterministic and efficient.
    
- **Time Complexity:** O(log n)
    
- **Space Complexity:** O(1)
    
- **Stable:** Not applicable (not a sorting algorithm).
    

## 3. Steps / Working

1. Initialize `low = 0`, `high = n-1`.
    
2. Compute `mid = (low + high) // 2`.
    
3. Compare `arr[mid]` with target:
    
    - If equal → found.
        
    - If smaller → search right half.
        
    - If larger → search left half.
        
4. Repeat until found or interval is empty.
    

## 4. Example (Python)

```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid  # target found
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1  # not found
```

## 5. Use Cases

- Searching in sorted arrays.
    
- Range queries.
    
- Problem solving with monotonic functions.
    

## 6. Variations / Related Concepts

- Lower Bound / Upper Bound.
    
- Binary Search on Monotonic Functions.
    
- Binary Search over Input / Output Space.
    
- Binary Search on Floating Point.
    

## 7. Common Mistakes & Pitfalls

- Forgetting sorted requirement.
    
- Incorrect loop condition (`low < high` vs `low <= high`).
    
- Infinite loops (not updating bounds).
    
- Integer overflow in some languages when computing `mid`.
    

## 8. Complexity Analysis

- **Time Complexity:** O(log n)
    
- **Space Complexity:** O(1)
    